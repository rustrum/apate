# Test specification which will be used with `cargo run`
#
# Configuration contains a list of so called "deceit" units.
# Each deceit provide responses for some set of URIs.
# It is not prohibited to have several deceit units 
# that mock same URI but I do not recommend it.
# 
# Deceit will try to match URI and apply matchers against request.
# On success response processing will be started.
# If deceit level matchers will fail then next deceit will be tried.
# Same logic apply for matchers on responses level.

# Mocking users list functionality
[[deceit]]
uris = ["/user/list"]
headers = [["Content-Type", "application/json"]]
matchers = [{ type = "method", eq = "GET" }]

[[deceit.responses]]
matchers = [{ type = "query_arg", name = "name", value = "Ivan" }]
output = """
[
    {"id":42, "name":"Ivan", "surname": "Ivanov"},
]

"""

[[deceit.responses]]
matchers = [{ type = "query_arg", name = "name", value = "Adolph" }]
output = """
[
    {"id":740, "name":"Adolph", "surname": "Greenberg"},
    {"id":741, "name":"Adolph", "surname": "Shtern"},
    {"id":742, "name":"Adolph", "surname": "Feldman"}
]

"""

[[deceit.responses]]
code = 503
matchers = [{ type = "query_arg", name = "name", value = "Rajesh" }]
output = """
{"message": "Impossible to list them all"}

"""

[[deceit.responses]]
output = """
[
    {"id":42, "name":"Ivan", "surname": "Ivanov"},
    {"id":740, "name":"Adolph", "surname": "Greenberg"},
    {"id":741, "name":"Adolph", "surname": "Shtern"},
    {"id":742, "name":"Adolph", "surname": "Feldman"}
]

"""

# Mocking user add functionality
[[deceit]]
uris = ["/user/add"]
headers = [["Content-Type", "application/json"]]
matchers = [{ type = "method", eq = "POST" }]

[[deceit.responses]]
code = 416
# There are matchers with types "and"/"or" which can combine other matchers
matchers = [
    { type = "or", matchers = [
        # As you've already guessed only one matcher below could be true
        { type = "json", path = "$.name", eq = "Rajesh" },
        { type = "json", path = "$.name", eq = "Abhishek" },
        { type = "json", path = "$.name", eq = "Ram" },
        { type = "json", path = "$.name", eq = "Sri" },
        { type = "json", path = "$.name", eq = "Ramesh" },
    ] },
]
type = "jinja"
output = """
{
    "error": "Name {{ ctx.load_body_json().name }} occupy too much space in our DB.",
    "message": "Be creative, invent another name!"
}

"""

[[deceit.responses]]
code = 406
matchers = [
    { type = "json", path = "$.name", eq = "Adolph" },
    { type = "json", path = "$.surname", eq = "Hitler" },
]
output = """
{"message": "Nun wird Terror mit Terror beantwortet"}

"""

[[deceit.responses]]
type = "jinja"
output = """
{%- set input = ctx.load_body_json() %}
{ "id": 42, "name": "{{ input.name }}", "surname": "{{ input.surname }}" }

"""

# Mocking user get functionality
[[deceit]]
uris = ["/user/{user_id}", "/user"]
headers = [["Content-Type", "application/json"]]
matchers = [{ type = "method", eq = "GET" }]

# This would match only for /user?id=42
[[deceit.responses]]
matchers = [{ type = "query_arg", name = "id", value = "42" }]
output = """
{"id":42, "name":"Ivan", "surname": "Ivanov"}

"""

# This one is /user/740
[[deceit.responses]]
matchers = [{ type = "path_arg", name = "user_id", value = "740" }]
output = """
{"id":740, "name":"Adolph", "surname": "Greenberg"}

"""

# Also we can use some template engine logic to do tricky  stuff :)
[[deceit.responses]]
type = "jinja"
output = """
{%- if ctx.load_query_args().id %}
    {%- set id = ctx.load_query_args().id %}
{%- elif ctx.load_path_args().user_id %}
    {%- set id = ctx.load_path_args().user_id %}
{%- else %}
    {%- set _ = ctx.set_response_code(500) %}
{%- endif %}
{%- if id %}
{"id":"{{ id }}", "name":"Rajesh", "surname": "undefined is not a function"}
{%- else %}
{"message":"Unknow ID for some Rajesh or Ivan"}
{%- endif %}

"""
