#
# The most useful example that combines features described below.
# Basically we using template output as raw JSON source 
# that is filtered by shared post processor based on query string arguments.
# /rhai/search?surname=Ivanov - will return only records with this surname.
#
[[deceit]]
uris = ["/rhai/search"]
headers = [["Content-Type", "application/json"]]

[[deceit.responses]]
output = """
[
{ "name": "Ivan", "surname": "Ivanov"},
{ "name": "Adolph", "surname": "Gupta"},
{ "name": "John", "surname": "Smith"},
{ "name": "Ivan", "surname": "Smith"},
{ "name": "Adolph", "surname": "Ivanov"}
]
"""

[[deceit.processors]]
type = "rhai_ref"
id = "rhai-filter"

#
# Rhai as a template engine
#
[[deceit]]
uris = ["/rhai/list"]
headers = [["Content-Type", "application/json"]]

# Rhai template is very similar to processor but it has only `ctx` glob variable.
# I found rhai even more convenient that minijinja in some cases
[[deceit.responses]]
type = "rhai"
output = """
let data = [
    #{ name: "Ivan", surname: "Ivanov"},
    #{ name: "Adolph", surname: "Gupta"},
    #{ name: "John", surname: "Smith"},
    #{ name: "Ivan", surname: "Smith"},
    #{ name: "Adolph", surname: "Ivanov"}
];

let q = ctx.load_query_args();

if "name" in q {
    data = data.filter(|rec| rec.name == q["name"]);
}

if "surname" in q {
    data = data.filter(|rec| rec.surname == q["surname"]);
}

// This is custom funtion that converts Rhai type to json blob
return to_json_blob(data);
"""

#
# Rhai as a matcher
#
[[deceit]]
uris = ["/rhai/match"]
headers = [["Content-Type", "application/json"]]

# This is an example of how to use RHAI script in matchers
# if you need a complex matching rules against input
[[deceit.matchers]]
type = "rhai"
script = """
// All matchers has `ctx` variable with request context

// There are some logging capabilities
print(`CTX path is: ${ctx.path}`);
// Debug output is also possible
debug(`CTX path is: ${ctx.path}`);

// load_* functions means that this operation is expensive
let headers = ctx.load_headers();
if "User-Agent" in headers {
    let agent = headers.get("User-Agent");
    print(`User-Agent is: ${agent}`);
}

let query_args = ctx.load_query_args();
if "foo" in query_args {
    print(`Query arg "foo" is: ${query_args.foo}`);
}

// You will not get a response if /rhai/match?foo=none
if query_args.foo == "none" {
    return false;
}

return true;
"""

[[deceit.responses]]
output = """
{"message": "Rhai inline matcher is OK"},
"""


#
# Rhai matcher reusable script
#
[[deceit]]
uris = ["/rhai/match/ref"]
headers = [["Content-Type", "application/json"]]

# This time we use global Rhai script definition (for reusability purpose)
# You can address global script by ID in any matcher and provide some custom input for it
[[deceit.matchers]]
type = "rhai_ref"
id = "top-level-script"
args = ["arg1", "arg2"]

[[deceit.responses]]
output = """
{"message": "Rhai top level matcher is OK"}
"""

#
# Rhai as a processor srcipt
# Basically it is the same as a template script but with additional context
#
[[deceit]]
uris = ["/rhai/post"]
headers = [["Content-Type", "application/json"]]

[[deceit.responses]]
output = """
{"message": "Rhai post processor is working"}
"""

# This time we use global Rhai script definition (for reusability purpose)
# You can address global script by ID in any matcher and provide some custom input for it
[[deceit.processors]]
type = "rhai"
script = """
// Rhai processor has next context variables:
// - ctx - with response context
// - args - with custom arguments if any
// - body - with response body as bytes (blob)

let json_map = parse_json(body.as_string());
json_map.post = "hello from script post processor";

// Post processor return is mandatory.
// You can skip if you wan to have original response
return json_map.to_json().to_blob();
"""

# This post processor will run after a previous one
# and will use body returned by it
[[deceit.processors]]
type = "rhai_ref"
id = "rhai-post-processor"
args = ["argumen1", "argument2"]


#
# Reusable Rhai scripts registry
# This could be processor or matcher that references by IN in specs
#
[[rhai]]
id = "top-level-script"
script = """
// Top level script has two global variables:
// - ctx - with context (depending on script type)
// - args - user defined args as a list of strings

if args.is_empty() {
    print("No args were provided");
} else {
    print(`Provided args: ${args}`);
}

// You will not get a response if /rhai/match/ref?foo=none
if ctx.load_query_args().foo == "none" {
    return false
}

return true
"""

[[rhai]]
id = "rhai-post-processor"
script = """
// Rhai processor has next context variables:
// - ctx - with response context
// - args - with custom arguments if any
// - body - with response body as bytes (blob)

let json_map = parse_json(body.as_string());

let fields_count = json_map.len();

json_map.post_ref = `Map len() returned ${fields_count}`;
json_map.args = args;

return json_map.to_json().to_blob();
"""


[[rhai]]
id = "rhai-filter"
script= """
let data = from_json_blob(body);

let query = ctx.load_query_args();
for arg in query.keys() {
    data = data.filter(|rec| {
        if arg in rec {
            rec[arg].to_string().to_lower() == query[arg].to_lower()
        } else {
            false
        }
    });
}

// This is custom funtion that converts Rhai type to json blob
return to_json_blob(data);
"""