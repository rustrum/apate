# Explaining some advanced template language features
# BTW apate use minijinja template engine which has jina compatible syntax.

# Apate template functions
[[deceit]]
uris = ["/tpl/fn"]
headers = [["Content-Type", "text/markdown"]]
[[deceit.responses]]
type = "jinja"
output = """
# Template functions

## ctx.force_response_code(http_code)

This function force/overwrite response code for this request.
{%- set _ = ctx.set_response_code(200) %}


## ctx.inc_counter("key")

By input key returns previous counter value and increment counter by one on each function call.
 
 - ctx.inc_counter("test1"): {{ ctx.inc_counter("test1") }}
 - ctx.inc_counter("test2"): {{ ctx.inc_counter("test2") }}
 - ctx.inc_counter("test2") + 42: {{ ctx.inc_counter("test2") + 42 }}


## uuid_v4()

Returns random UUID v4: {{ uuid_v4() }}


## random_num() || random_num(max) || random_num(from, to)

Return random number in some range:
 
 - random_num(): {{ random_num() }}
 - random_num(42): {{ random_num(42) }}
 - random_num(42, 69): {{ random_num(42, 69) }}


 ## random_hex() || random_hex(bytes_len)

 Return random hex string for some bytes length or default.

  - random_hex(): {{ random_hex() }}
  - random_hex(8): {{ random_hex(8) }}
  - random_hex(4)-random_hex(8)-random_hex(2): {{ random_hex(4) }}-{{ random_hex(8) }}-{{ random_hex(2) }}

"""


# Accessing context from template
[[deceit]]
uris = ["/tpl/ctx", "/tpl/ctx/{custom_value}"]
headers = [["Content-Type", "text/markdown"]]
[[deceit.responses]]
type = "jinja"
output = """
# Accessing request context


## Current path
Available in `ctx.path` variable.

Current path is: {{ ctx.path }}


## Path arguments

Path arguments from uri pattern can be accessed via `ctx.load_path_args()` dictionary.

Path argument `custom_value` is: {{ ctx.load_path_args().custom_value | default('DOES_NOT_EXIST') }}


## Query string arguments

Template has context variable `ctx.load_query_args()` which is a map with all query string arguments.

Query string arguments found:

{%- for key in ctx.load_query_args() if ctx.load_query_args() %}
 - {{ key }} -> {{ ctx.load_query_args()[key] }}
{%- endfor %}


## Request JSON payload

If request payload is parsed as JSON it will be available as `ctx.load_body_json()`.
{%- if ctx.load_body_json() %}

JSON that was parsed and then encoded back: {{ ctx.load_body_json() | tojson }}
{%- endif %}


## Headers

Also template has a map variable `ctx.load_headers()` with all request headers.

Request headers are:

{%- for key in ctx.load_headers() if ctx.load_headers() %}
 - {{ key }} -> {{ ctx.load_headers()[key] }}
{%- endfor %}

"""
