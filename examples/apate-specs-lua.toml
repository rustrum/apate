[[deceit]]
uris = ["/lua/match"]
headers = [["Content-Type", "application/json"]]

# This is an example of how to use LUA script in matchers
# if you need a complex matching rules against input
[[deceit.matchers]]
type = "lua"
script = """
-- matcher has a single input arg with a request context
local ctx = select(1, ...)

-- you have some logging capabilities here
log("Ctx path is: " .. ctx:path())

local agent = ctx:get_header("User-Agent")
if agent then
    
    log("User agent is: " .. agent)
end

local foo = ctx:get_query_arg("foo")
if foo then
    -- log warnings are also possible
    log_warn("Query arg \\"foo\\" is: " .. foo)
end

-- You will not get a response if /lua/match?foo=none
if foo == "none" then
    return false
end

return true
"""

[[deceit.responses]]
output = """
{"message": "Lua inline matcher is OK"},
"""


[[deceit]]
uris = ["/lua/glob"]
headers = [["Content-Type", "application/json"]]

# This time we use global lua script definition (for reusability purpose)
# You can address global script by ID in any matcher and provide some custom input for it
[[deceit.matchers]]
type = "lua_script"
id = "top-level-script"
args = ["arg1", "arg2"]

[[deceit.responses]]
output = """
{"message": "Lua top level matcher is OK"},
"""


# This is our global LUA scripts definitions
[[lua]]
id = "top-level-script"
script = """
-- input args
local ctx = select(1, ...) -- context that depends on script execution scope
local args = select(2, ...) -- custom arguments as array of strings


if args then
    log("Provided args: " .. table.concat(args, ", "))
else
    log("No args were provided")
end

-- You will not get a response if /lua/glob?foo=none
local foo = ctx:get_query_arg("foo")
if foo == "none" then
    return false
end


return true
"""